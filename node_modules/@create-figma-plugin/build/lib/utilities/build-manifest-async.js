import { constants, readConfigAsync } from '@create-figma-plugin/common';
import fs from 'fs-extra';
import { resolve } from 'path';
export async function buildManifestAsync(minify) {
    const config = await readConfigAsync();
    const { api, build, capabilities, commandId, containsWidget, editorType, enablePrivatePluginApi, enableProposedApi, id, main, menu, name, parameterOnly, parameters, permissions, relaunchButtons, ui, widgetApi } = config;
    const command = { commandId, main, menu, name, parameterOnly, parameters, ui };
    if (hasBundle(command, 'main') === false) {
        throw new Error('Need a `main` entry point');
    }
    const hasUi = hasBundle(command, 'ui') === true ||
        (relaunchButtons !== null &&
            relaunchButtons.filter(function (relaunchButton) {
                return relaunchButton.ui !== null;
            }).length > 0);
    const manifest = {
        api,
        widgetApi: containsWidget === true ? widgetApi : undefined,
        editorType,
        containsWidget: containsWidget === true ? containsWidget : undefined,
        id,
        name,
        main: constants.build.pluginCodeFilePath,
        ui: hasUi === true ? constants.build.pluginUiFilePath : undefined,
        parameters: command.parameters !== null
            ? createParameters(command.parameters)
            : undefined,
        parameterOnly: command.parameterOnly === false ? false : undefined,
        menu: command.menu !== null ? createMenu(command.menu) : undefined,
        relaunchButtons: relaunchButtons !== null
            ? createRelaunchButtons(relaunchButtons)
            : undefined,
        permissions: permissions !== null ? permissions : undefined,
        capabilities: capabilities !== null ? capabilities : undefined,
        enableProposedApi: enableProposedApi === true ? true : undefined,
        enablePrivatePluginApi: enablePrivatePluginApi === true ? true : undefined,
        build: build !== null ? build : undefined
    };
    const result = await overrideManifestAsync(manifest);
    const string = (minify === true
        ? JSON.stringify(result)
        : JSON.stringify(result, null, 2)) + '\n';
    await fs.outputFile(constants.build.manifestFilePath, string);
}
function hasBundle(command, key) {
    if (command[key] !== null) {
        return true;
    }
    if (command.menu !== null) {
        const result = command.menu.filter(function (command) {
            if ('separator' in command) {
                return false;
            }
            return hasBundle(command, key);
        });
        return result.length > 0;
    }
    return false;
}
function createParameters(parameters) {
    return parameters.map(function (parameter) {
        const result = {
            key: parameter.key,
            name: parameter.name
        };
        if (parameter.description !== null) {
            result.description = parameter.description;
        }
        if (parameter.allowFreeform === true) {
            result.allowFreeform = true;
        }
        if (parameter.optional === true) {
            result.optional = true;
        }
        return result;
    });
}
function createMenu(menu) {
    return menu.map(function (item) {
        if ('separator' in item) {
            return { separator: true };
        }
        const result = {
            name: item.name
        };
        if (item.commandId !== null) {
            result.command = item.commandId;
        }
        if (item.parameters !== null) {
            result.parameters = createParameters(item.parameters);
        }
        if (item.parameterOnly === false) {
            result.parameterOnly = false;
        }
        if (item.menu !== null) {
            result.menu = createMenu(item.menu);
        }
        return result;
    });
}
function createRelaunchButtons(relaunchButtons) {
    return relaunchButtons.map(function (relaunchButton) {
        const result = {
            name: relaunchButton.name,
            command: relaunchButton.commandId
        };
        if (relaunchButton.multipleSelection === true) {
            result.multipleSelection = true;
        }
        return result;
    });
}
async function overrideManifestAsync(manifest) {
    const absolutePath = resolve(constants.build.manifestConfigFilePath);
    if ((await fs.pathExists(absolutePath)) === false) {
        return manifest;
    }
    const { default: overrideManifest } = await import(absolutePath);
    return overrideManifest(manifest);
}
//# sourceMappingURL=build-manifest-async.js.map