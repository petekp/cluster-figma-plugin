import { evaluateNumericExpression, isValidNumericInput, MIXED_NUMBER, MIXED_STRING } from '@create-figma-plugin/utilities';
import { h } from 'preact';
import { useCallback, useRef, useState } from 'preact/hooks';
import { getCurrentFromRef } from '../../../../utilities/get-current-from-ref';
import { computeNextValue } from '../../private/compute-next-value';
import { isKeyCodeCharacterGenerating } from '../../private/is-keycode-character-generating';
import { formatEvaluatedValue } from './format-evaluated-value';
const FRACTION_DIGITS = 3;
const EMPTY_STRING = "";
export function RawTextboxNumeric({ disabled = false, incrementBig = 10, incrementSmall = 1, integer = false, maximum, minimum, name, onInput = function () { }, onNumericValueInput = function () { }, onValueInput = function () { }, placeholder, propagateEscapeKeyDown = true, revertOnEscapeKeyDown = false, suffix, validateOnBlur, value, ...rest }) {
    if (typeof minimum !== "undefined" &&
        typeof maximum !== "undefined" &&
        minimum >= maximum) {
        throw new Error("`minimum` must be less than `maximum`");
    }
    const inputElementRef = useRef(null);
    const revertOnEscapeKeyDownRef = useRef(false);
    const [originalValue, setOriginalValue] = useState(EMPTY_STRING);
    const setInputElementValue = useCallback(function (value) {
        const inputElement = getCurrentFromRef(inputElementRef);
        inputElement.value = value;
        const inputEvent = document.createEvent("Event");
        inputEvent.initEvent("input", true, true);
        inputElement.dispatchEvent(inputEvent);
    }, []);
    const handleBlur = useCallback(function () {
        if (revertOnEscapeKeyDownRef.current === true) {
            revertOnEscapeKeyDownRef.current = false;
            return;
        }
        if (typeof validateOnBlur !== "undefined") {
            const evaluatedValue = evaluateValue(value, suffix);
            const result = validateOnBlur(evaluatedValue);
            if (typeof result === "number") {
                setInputElementValue(formatEvaluatedValue(result, value, suffix));
                setOriginalValue(EMPTY_STRING);
                return;
            }
            if (result === null) {
                setInputElementValue(EMPTY_STRING);
                setOriginalValue(EMPTY_STRING);
                return;
            }
            if (result === false) {
                if (value !== originalValue) {
                    setInputElementValue(originalValue);
                }
                setOriginalValue(EMPTY_STRING);
                return;
            }
        }
        if (typeof suffix !== "undefined" && value === suffix) {
            setInputElementValue(EMPTY_STRING);
            setOriginalValue(EMPTY_STRING);
            return;
        }
        if (value !== EMPTY_STRING && value !== MIXED_STRING) {
            const evaluatedValue = evaluateValue(value, suffix);
            const formattedValue = formatEvaluatedValue(evaluatedValue, value, suffix);
            if (value !== formattedValue) {
                setInputElementValue(formattedValue);
            }
        }
        setOriginalValue(EMPTY_STRING);
    }, [originalValue, setInputElementValue, suffix, validateOnBlur, value]);
    const handleFocus = useCallback(function (event) {
        setOriginalValue(value);
        event.currentTarget.select();
    }, [value]);
    const handleInput = useCallback(function (event) {
        onInput(event);
        const value = event.currentTarget.value;
        onValueInput(value, name);
        const evaluatedValue = evaluateValue(value, suffix);
        onNumericValueInput(evaluatedValue, name);
    }, [name, onInput, onNumericValueInput, onValueInput, suffix]);
    const handleKeyDown = useCallback(function (event) {
        const key = event.key;
        if (key === "Escape") {
            if (propagateEscapeKeyDown === false) {
                event.stopPropagation();
            }
            if (revertOnEscapeKeyDown === true) {
                revertOnEscapeKeyDownRef.current = true;
                setInputElementValue(originalValue);
                setOriginalValue(EMPTY_STRING);
            }
            event.currentTarget.blur();
            return;
        }
        if (key === "Enter") {
            event.currentTarget.blur();
            return;
        }
        const element = event.currentTarget;
        if (key === "ArrowDown" || key === "ArrowUp") {
            const delta = event.shiftKey === true ? incrementBig : incrementSmall;
            if (value === EMPTY_STRING || value === MIXED_STRING) {
                event.preventDefault();
                const startingValue = (function () {
                    if (typeof minimum !== "undefined" && minimum > 0) {
                        return minimum;
                    }
                    if (typeof maximum !== "undefined" && maximum < 0) {
                        return maximum;
                    }
                    return 0;
                })();
                const newValue = restrictValue(evaluateValueWithDelta(startingValue, key === "ArrowDown" ? -1 * delta : delta), minimum, maximum);
                const formattedValue = formatEvaluatedValue(newValue, value, suffix);
                element.value = formattedValue;
                element.select();
                handleInput(event);
                return;
            }
            const evaluatedValue = evaluateValue(value, suffix);
            if (evaluatedValue === null) {
                throw new Error("Invariant violation");
            }
            event.preventDefault();
            const newValue = restrictValue(evaluateValueWithDelta(evaluatedValue, key === "ArrowDown" ? -1 * delta : delta), minimum, maximum);
            const formattedValue = formatEvaluatedValue(newValue, value, suffix);
            if (formattedValue === value) {
                return;
            }
            element.value = formattedValue;
            element.select();
            handleInput(event);
            return;
        }
        if (event.ctrlKey === true || event.metaKey === true) {
            return;
        }
        if (isKeyCodeCharacterGenerating(event.keyCode) === true) {
            const nextValue = trimSuffix(value === MIXED_STRING
                ? event.key
                : computeNextValue(element, event.key), suffix);
            if (isValidNumericInput(nextValue, { integersOnly: integer }) === false) {
                event.preventDefault();
                return;
            }
            if (typeof minimum === "undefined" && typeof maximum === "undefined") {
                return;
            }
            const evaluatedValue = evaluateNumericExpression(nextValue);
            if (evaluatedValue === null) {
                return;
            }
            if ((typeof minimum !== "undefined" && evaluatedValue < minimum) ||
                (typeof maximum !== "undefined" && evaluatedValue > maximum)) {
                event.preventDefault();
            }
        }
    }, [
        handleInput,
        incrementBig,
        incrementSmall,
        integer,
        maximum,
        minimum,
        originalValue,
        propagateEscapeKeyDown,
        revertOnEscapeKeyDown,
        setInputElementValue,
        suffix,
        value
    ]);
    const handleMouseUp = useCallback(function (event) {
        if (value !== MIXED_STRING) {
            return;
        }
        event.preventDefault();
    }, [value]);
    const handlePaste = useCallback(function (event) {
        if (event.clipboardData === null) {
            throw new Error("`event.clipboardData` is `null`");
        }
        const nextValue = trimSuffix(computeNextValue(event.currentTarget, event.clipboardData.getData("Text")), suffix);
        if (isValidNumericInput(nextValue, {
            integersOnly: integer
        }) === false) {
            event.preventDefault();
        }
    }, [integer, suffix]);
    return (h("input", { ...rest, ref: inputElementRef, disabled: disabled === true, name: name, onBlur: handleBlur, onFocus: handleFocus, onInput: handleInput, onKeyDown: handleKeyDown, onMouseUp: handleMouseUp, onPaste: handlePaste, placeholder: placeholder, spellcheck: false, tabIndex: disabled === true ? -1 : 0, type: "text", value: value === MIXED_STRING ? "Mixed" : value }));
}
function restrictValue(value, minimum, maximum) {
    if (typeof minimum !== "undefined") {
        if (typeof maximum !== "undefined") {
            return Math.min(Math.max(value, minimum), maximum);
        }
        return Math.max(value, minimum);
    }
    if (typeof maximum !== "undefined") {
        return Math.min(value, maximum);
    }
    return value;
}
function evaluateValue(value, suffix) {
    if (value === MIXED_STRING) {
        return MIXED_NUMBER;
    }
    if (value === EMPTY_STRING) {
        return null;
    }
    return evaluateNumericExpression(trimSuffix(value, suffix));
}
function evaluateValueWithDelta(value, delta) {
    return parseFloat((value + delta).toFixed(FRACTION_DIGITS));
}
function trimSuffix(string, suffix) {
    if (typeof suffix === "undefined") {
        return string;
    }
    return string.replace(new RegExp(`${suffix}$`), EMPTY_STRING);
}
//# sourceMappingURL=raw-textbox-numeric.js.map